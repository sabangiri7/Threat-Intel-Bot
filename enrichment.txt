"""
Enrichment Orchestrator - Phase 2
Automated Threat Intelligence Bot for SOC Analysts

Orchestrates enrichment from all 4 APIs:
- VirusTotal (malware detection ratios)
- AlienVault OTX (threat campaigns, pulses)
- ThreatFox (malware families, C2 infrastructure)
- AbuseIPDB (IP abuse reputation)

Normalizes responses, aggregates confidence scores, and provides
unified enrichment output for downstream correlation and triage.
"""

import os
import time
import json
import logging
from typing import Dict, List, Optional
from datetime import datetime
from dotenv import load_dotenv

# Import API handlers
try:
    from src.api_handlers.virustotal_handler import VirusTotalHandler
    from src.api_handlers.otx_handler import OTXHandler
    from src.api_handlers.threatfox_handler import ThreatFoxHandler
    from src.api_handlers.abuseipdb_handler import AbuseIPDBHandler
except ImportError:
    from api_handlers.virustotal_handler import VirusTotalHandler
    from api_handlers.otx_handler import OTXHandler
    from api_handlers.threatfox_handler import ThreatFoxHandler
    from api_handlers.abuseipdb_handler import AbuseIPDBHandler

load_dotenv()

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class IOCEnricher:
    """
    Orchestrates enrichment of IOCs from multiple OSINT APIs.
    
    Confidence Weighting Strategy:
    - VirusTotal: 35% (high quality, community-driven detections)
    - OTX: 30% (threat campaigns, tactical intelligence)
    - ThreatFox: 20% (malware families, infrastructure)
    - AbuseIPDB: 15% (IP reputation, abuse scoring)
    
    Total: 100% aggregated into 0.0-1.0 confidence score
    """
    
    # Confidence weighting (must sum to 1.0)
    API_WEIGHTS = {
        'virustotal': 0.35,
        'otx': 0.30,
        'threatfox': 0.20,
        'abuseipdb': 0.15
    }
    
    def __init__(self, use_cache: bool = True):
        """
        Initialize the enrichment orchestrator.
        
        Args:
            use_cache (bool): Whether to use caching for API responses
        """
        logger.info("Initializing IOC Enricher with 4 API handlers")
        
        # Initialize API handlers
        self.vt = VirusTotalHandler()
        self.otx = OTXHandler()
        self.tf = ThreatFoxHandler()
        self.abuse = AbuseIPDBHandler()
        
        # Tracking
        self.enrichment_count = 0
        self.error_count = 0
        self.cache = {} if use_cache else None
        
        logger.info("✅ All 4 API handlers initialized successfully")
    
    def enrich_ioc(self, ioc_value: str, ioc_type: str) -> Dict:
        """
        Enrich a single IOC from all available APIs.
        
        Workflow:
        1. Validate IOC type
        2. Call appropriate API handlers (based on type)
        3. Normalize each response
        4. Aggregate confidence scores
        5. Return enriched IOC with confidence
        
        Args:
            ioc_value (str): The IOC value (IP, domain, URL, hash)
            ioc_type (str): Type of IOC (IP, domain, URL, hash)
            
        Returns:
            Dict: Enriched IOC with:
                - ioc_value, ioc_type
                - enrichment data from each API
                - unified_confidence (0.0-1.0)
                - triage_action (BLOCK, MONITOR, IGNORE, QUARANTINE)
        """
        logger.info(f"Enriching IOC: {ioc_value} (type: {ioc_type})")
        
        # Validate IOC type
        valid_types = ['IP', 'domain', 'URL', 'hash']
        if ioc_type not in valid_types:
            logger.warning(f"Invalid IOC type: {ioc_type}")
            return {
                'ioc_value': ioc_value,
                'ioc_type': ioc_type,
                'status': 'error',
                'error': f'Invalid IOC type: {ioc_type}. Expected one of {valid_types}',
                'unified_confidence': 0.0,
                'timestamp': datetime.utcnow().isoformat()
            }
        
        # Check cache first
        cache_key = f"{ioc_value}_{ioc_type}"
        if self.cache is not None and cache_key in self.cache:
            logger.info(f"Cache hit for {cache_key}")
            return self.cache[cache_key]
        
        # Initialize enrichment result
        enrichment_result = {
            'ioc_value': ioc_value,
            'ioc_type': ioc_type,
            'timestamp': datetime.utcnow().isoformat(),
            'api_results': {},
            'confidence_scores': {},
            'errors': []
        }
        
        try:
            # Call APIs based on IOC type
            if ioc_type == 'IP':
                enrichment_result['api_results']['virustotal'] = self._safe_call(
                    lambda: self.vt.check_ip(ioc_value),
                    'VirusTotal',
                    enrichment_result['errors']
                )
                enrichment_result['api_results']['otx'] = self._safe_call(
                    lambda: self.otx.check_ip(ioc_value),
                    'OTX',
                    enrichment_result['errors']
                )
                enrichment_result['api_results']['threatfox'] = self._safe_call(
                    lambda: self.tf.check_ioc(ioc_value),
                    'ThreatFox',
                    enrichment_result['errors']
                )
                enrichment_result['api_results']['abuseipdb'] = self._safe_call(
                    lambda: self.abuse.check_ip(ioc_value),
                    'AbuseIPDB',
                    enrichment_result['errors']
                )
            
            elif ioc_type == 'domain':
                enrichment_result['api_results']['virustotal'] = self._safe_call(
                    lambda: self.vt.check_domain(ioc_value),
                    'VirusTotal',
                    enrichment_result['errors']
                )
                enrichment_result['api_results']['otx'] = self._safe_call(
                    lambda: self.otx.check_domain(ioc_value),
                    'OTX',
                    enrichment_result['errors']
                )
                enrichment_result['api_results']['threatfox'] = self._safe_call(
                    lambda: self.tf.check_ioc(ioc_value),
                    'ThreatFox',
                    enrichment_result['errors']
                )
            
            elif ioc_type == 'URL':
                enrichment_result['api_results']['virustotal'] = self._safe_call(
                    lambda: self.vt.check_url(ioc_value),
                    'VirusTotal',
                    enrichment_result['errors']
                )
                enrichment_result['api_results']['otx'] = self._safe_call(
                    lambda: self.otx.check_url(ioc_value),
                    'OTX',
                    enrichment_result['errors']
                )
                enrichment_result['api_results']['threatfox'] = self._safe_call(
                    lambda: self.tf.check_ioc(ioc_value),
                    'ThreatFox',
                    enrichment_result['errors']
                )
            
            elif ioc_type == 'hash':
                enrichment_result['api_results']['virustotal'] = self._safe_call(
                    lambda: self.vt.check_hash(ioc_value),
                    'VirusTotal',
                    enrichment_result['errors']
                )
                enrichment_result['api_results']['otx'] = self._safe_call(
                    lambda: self.otx.check_hash(ioc_value),
                    'OTX',
                    enrichment_result['errors']
                )
                enrichment_result['api_results']['threatfox'] = self._safe_call(
                    lambda: self.tf.check_ioc(ioc_value),
                    'ThreatFox',
                    enrichment_result['errors']
                )
            
            # Compute confidence scores from each API
            enrichment_result['confidence_scores'] = self._compute_confidence_scores(
                enrichment_result['api_results'],
                ioc_type
            )
            
            # Aggregate confidence (weighted average)
            unified_confidence = self._aggregate_confidence(
                enrichment_result['confidence_scores']
            )
            enrichment_result['unified_confidence'] = unified_confidence
            
            # Generate triage recommendation
            enrichment_result['triage_action'] = self._recommend_action(
                unified_confidence,
                enrichment_result['api_results']
            )
            
            enrichment_result['status'] = 'success'
            self.enrichment_count += 1
            
            logger.info(
                f"✅ Enrichment complete: {ioc_value} "
                f"(confidence: {unified_confidence:.2f}, action: {enrichment_result['triage_action']})"
            )
            
        except Exception as e:
            logger.error(f"❌ Enrichment error: {str(e)}")
            enrichment_result['status'] = 'error'
            enrichment_result['error'] = str(e)
            enrichment_result['unified_confidence'] = 0.0
            self.error_count += 1
        
        # Cache the result
        if self.cache is not None:
            self.cache[cache_key] = enrichment_result
        
        return enrichment_result
    
    def enrich_batch(self, iocs: List[Dict]) -> List[Dict]:
        """
        Enrich a batch of IOCs.
        
        Args:
            iocs (List[Dict]): List of IOCs, each with 'ioc_value' and 'ioc_type'
            
        Returns:
            List[Dict]: Enriched IOCs with confidence scores
        """
        logger.info(f"Starting batch enrichment of {len(iocs)} IOCs")
        
        enriched = []
        for idx, ioc in enumerate(iocs, 1):
            ioc_value = ioc.get('ioc_value')
            ioc_type = ioc.get('ioc_type')
            
            if not ioc_value or not ioc_type:
                logger.warning(f"Skipping IOC {idx}: missing ioc_value or ioc_type")
                continue
            
            result = self.enrich_ioc(ioc_value, ioc_type)
            enriched.append(result)
            
            # Add small delay to respect API rate limits
            if idx < len(iocs):
                time.sleep(1)
        
        logger.info(f"✅ Batch enrichment complete: {len(enriched)} IOCs processed")
        return enriched
    
    def _safe_call(self, func, api_name: str, error_list: List) -> Optional[Dict]:
        """
        Safely call an API handler with error handling.
        
        Args:
            func: Callable API handler function
            api_name (str): Name of API (for logging)
            error_list (List): List to append errors to
            
        Returns:
            Dict: API response or None if error
        """
        try:
            logger.debug(f"Calling {api_name} API")
            result = func()
            
            if result and result.get('status') == 'success':
                logger.debug(f"✅ {api_name} returned success")
                return result
            else:
                error_msg = result.get('error', 'Unknown error') if result else 'No response'
                logger.debug(f"⚠️  {api_name} returned error: {error_msg}")
                error_list.append({
                    'api': api_name,
                    'error': error_msg,
                    'response': result
                })
                return result
        
        except Exception as e:
            logger.warning(f"❌ {api_name} exception: {str(e)}")
            error_list.append({
                'api': api_name,
                'error': str(e),
                'type': 'exception'
            })
            return None
    
    def _compute_confidence_scores(self, api_results: Dict, ioc_type: str) -> Dict:
        """
        Compute confidence score for each API.
        
        Scoring logic:
        - VirusTotal: detections/total_engines (0.0-1.0)
        - OTX: 0.0 if no pulses, 0.5 if some pulses, 1.0 if high-confidence pulses
        - ThreatFox: confidence_level/100 (API returns 0-100)
        - AbuseIPDB: abuse_score/100 (0-100)
        
        Args:
            api_results (Dict): Results from all APIs
            ioc_type (str): Type of IOC
            
        Returns:
            Dict: Confidence score for each API
        """
        scores = {}
        
        # VirusTotal confidence
        vt = api_results.get('virustotal')
        if vt and vt.get('status') == 'success':
            detections = vt.get('detections', 0)
            total = vt.get('total_engines', 1)
            if total > 0:
                scores['virustotal'] = min(detections / total, 1.0)
            else:
                scores['virustotal'] = 0.0
        else:
            scores['virustotal'] = 0.0
        
        # OTX confidence
        otx = api_results.get('otx')
        if otx and otx.get('status') == 'success':
            pulse_count = otx.get('pulse_count', 0)
            if pulse_count > 5:
                scores['otx'] = 1.0  # High confidence if many pulses
            elif pulse_count > 0:
                scores['otx'] = 0.5  # Medium confidence if some pulses
            else:
                scores['otx'] = 0.0  # No confidence if no pulses
        else:
            scores['otx'] = 0.0
        
        # ThreatFox confidence
        tf = api_results.get('threatfox')
        if tf and tf.get('status') == 'success':
            confidence = tf.get('confidence_level', 0)
            # ThreatFox returns 0-100, normalize to 0.0-1.0
            scores['threatfox'] = min(confidence / 100.0, 1.0) if confidence else 0.0
        else:
            scores['threatfox'] = 0.0
        
        # AbuseIPDB confidence (IP only)
        abuse = api_results.get('abuseipdb')
        if abuse and abuse.get('status') == 'success' and ioc_type == 'IP':
            abuse_score = abuse.get('abuse_confidence_score', 0)
            # AbuseIPDB returns 0-100, normalize to 0.0-1.0
            scores['abuseipdb'] = min(abuse_score / 100.0, 1.0)
        else:
            scores['abuseipdb'] = 0.0
        
        logger.debug(f"Confidence scores: {scores}")
        return scores
    
    def _aggregate_confidence(self, confidence_scores: Dict) -> float:
        """
        Aggregate confidence scores using weighted average.
        
        Args:
            confidence_scores (Dict): Individual API confidence scores
            
        Returns:
            float: Aggregated confidence (0.0-1.0)
        """
        total = 0.0
        weight_sum = 0.0
        
        for api_name, weight in self.API_WEIGHTS.items():
            score = confidence_scores.get(api_name, 0.0)
            total += score * weight
            weight_sum += weight
        
        # Normalize by weight sum (in case some APIs not called)
        if weight_sum > 0:
            aggregated = total / weight_sum
        else:
            aggregated = 0.0
        
        aggregated = min(max(aggregated, 0.0), 1.0)  # Clamp to [0.0, 1.0]
        
        logger.debug(f"Aggregated confidence: {aggregated:.4f}")
        return round(aggregated, 4)
    
    def _recommend_action(self, confidence: float, api_results: Dict) -> str:
        """
        Recommend a triage action based on confidence and API results.
        
        Triage Logic:
        - BLOCK: confidence > 0.8 (high confidence malicious)
        - QUARANTINE: 0.6 < confidence <= 0.8 (moderate-high suspicion)
        - MONITOR: 0.3 < confidence <= 0.6 (low-moderate suspicion)
        - IGNORE: confidence <= 0.3 (clean or unknown)
        
        Args:
            confidence (float): Unified confidence score (0.0-1.0)
            api_results (Dict): Results from all APIs
            
        Returns:
            str: Recommended action (BLOCK, QUARANTINE, MONITOR, IGNORE)
        """
        # Check for special cases (known-good IPs, CDNs, etc.)
        if self._is_known_good(api_results):
            return 'IGNORE'
        
        # Confidence-based recommendation
        if confidence > 0.8:
            return 'BLOCK'
        elif confidence > 0.6:
            return 'QUARANTINE'
        elif confidence > 0.3:
            return 'MONITOR'
        else:
            return 'IGNORE'
    
    def _is_known_good(self, api_results: Dict) -> bool:
        """
        Check if IOC is a known-good (whitelist).
        
        Known-good patterns:
        - Public DNS (8.8.8.8, 1.1.1.1, etc.)
        - Major cloud providers
        - CDNs
        
        Args:
            api_results (Dict): Results from all APIs
            
        Returns:
            bool: True if known-good, False otherwise
        """
        # Check if AbuseIPDB marked as whitelisted (for IPs)
        abuse = api_results.get('abuseipdb')
        if abuse and abuse.get('is_whitelisted'):
            logger.debug("IOC marked as whitelisted by AbuseIPDB")
            return True
        
        return False
    
    def get_stats(self) -> Dict:
        """
        Get enrichment statistics.
        
        Returns:
            Dict: Statistics about enrichment operations
        """
        return {
            'total_enrichments': self.enrichment_count,
            'total_errors': self.error_count,
            'cache_size': len(self.cache) if self.cache else 0,
            'api_weights': self.API_WEIGHTS
        }
    
    def clear_cache(self):
        """Clear the enrichment cache."""
        if self.cache is not None:
            self.cache.clear()
            logger.info("Cache cleared")


# ============================================================================
# MAIN - Demo/Testing
# ============================================================================

if __name__ == "__main__":
    """Demo: Enrich sample IOCs"""
    
    print("\n" + "="*70)
    print("PHASE 2: IOC ENRICHMENT ORCHESTRATOR")
    print("="*70)
    
    # Initialize enricher
    enricher = IOCEnricher(use_cache=True)
    
    # Sample IOCs for testing
    sample_iocs = [
        {"ioc_value": "8.8.8.8", "ioc_type": "IP"},
        {"ioc_value": "google.com", "ioc_type": "domain"},
        {"ioc_value": "192.168.1.1", "ioc_type": "IP"},
        {"ioc_value": "malicious.com", "ioc_type": "domain"},
    ]
    
    print(f"\nEnriching {len(sample_iocs)} sample IOCs...\n")
    
    results = enricher.enrich_batch(sample_iocs)
    
    # Display results
    for result in results:
        print(f"\n{'-'*70}")
        print(f"IOC: {result['ioc_value']} ({result['ioc_type']})")
        print(f"Status: {result.get('status', 'unknown')}")
        print(f"Unified Confidence: {result.get('unified_confidence', 0.0):.2f}")
        print(f"Triage Action: {result.get('triage_action', 'UNKNOWN')}")
        print(f"Timestamp: {result.get('timestamp')}")
        
        if result.get('errors'):
            print(f"Errors: {len(result['errors'])} API errors encountered")
    
    # Show statistics
    print(f"\n{'-'*70}")
    stats = enricher.get_stats()
    print(f"Statistics:")
    print(f"  Total Enrichments: {stats['total_enrichments']}")
    print(f"  Total Errors: {stats['total_errors']}")
    print(f"  Cache Size: {stats['cache_size']}")
    print("="*70 + "\n")